// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
    provider = "prisma-client-js"
    // Output to a fixed location to fix pnpm monorepo module resolution issues
    // This prevents "Cannot find module '.prisma/client/default'" errors in Next.js builds
    output   = "../generated/client"
    // Generate binaries for both local (macOS) and Vercel (Linux RHEL) platforms
    // This ensures Prisma Client works in both development and production environments
    binaryTargets = ["native", "rhel-openssl-3.0.x"]
}

datasource db {
    provider = "postgresql"
    url      = env("DATABASE_URL")
}

// Marketplace models for ButterGolf
model User {
    id                       String         @id @default(cuid())
    // Clerk user identifier for federated auth
    clerkId                  String         @unique
    email                    String         @unique
    name                     String // Required - sellers must have a name
    imageUrl                 String?
    // Stripe Connect seller account
    stripeConnectId          String?        @unique // Stripe Connect account ID
    stripeOnboardingComplete Boolean        @default(false) // Whether seller onboarding is complete
    stripeAccountStatus      String? // Current account status (active, pending, etc.)
    stripeAccountType        String?        @default("express") // Account type: "express" | "fully_embedded"
    stripeRequirementsDue    Json? // Currently due requirements from Stripe
    stripeRequirementsDeadline DateTime? // Deadline for requirements
    // Seller rating (cached for performance)
    averageRating            Float?         @default(0)
    ratingCount              Int            @default(0)
    // Soft deletion support
    isDeleted                Boolean        @default(false) // Quick filter flag for deleted users
    deletedAt                DateTime? // Timestamp when user was deleted from Clerk
    createdAt                DateTime       @default(now())
    updatedAt                DateTime       @updatedAt
    // Marketplace relations
    products                 Product[]
    ordersSold               Order[]        @relation("SellerOrders")
    ordersPurchased          Order[]        @relation("BuyerOrders")
    addresses                Address[]
    ratingsReceived          SellerRating[] @relation("SellerRatings")
    ratingsGiven             SellerRating[] @relation("RatingsGiven")
    buyerOffers              Offer[]        @relation("BuyerOffers")
    sellerOffers             Offer[]        @relation("SellerOffers")
    favourites               Favourite[]

    @@index([isDeleted])
    @@map("users")
}

model Category {
    id          String    @id @default(cuid())
    name        String    @unique
    slug        String    @unique
    description String?
    imageUrl    String?
    sortOrder   Int       @default(0)
    createdAt   DateTime  @default(now())
    updatedAt   DateTime  @updatedAt
    products    Product[]

    @@map("categories")
}

model Brand {
    id         String      @id @default(cuid())
    name       String      @unique
    slug       String      @unique
    logoUrl    String?
    sortOrder  Int         @default(0)
    createdAt  DateTime    @default(now())
    updatedAt  DateTime    @updatedAt
    products   Product[]
    clubModels ClubModel[]

    @@map("brands")
}

enum ClubKind {
    DRIVER
    FAIRWAY_WOOD
    HYBRID
    IRON_SET
    WEDGE
    PUTTER
    BALL
    BAG
    APPAREL
    ACCESSORY
    OTHER
}

model ClubModel {
    id         String    @id @default(cuid())
    brandId    String
    brand      Brand     @relation(fields: [brandId], references: [id], onDelete: Cascade)
    name       String // e.g., "Apex 21", "Stealth 2"
    kind       ClubKind
    isVerified Boolean   @default(false) // Promoted after multiple uses
    usageCount Int       @default(0) // How many times this model has been listed
    createdAt  DateTime  @default(now())
    updatedAt  DateTime  @updatedAt

    @@unique([brandId, name, kind])
    @@index([brandId])
    @@index([isVerified])
    @@index([usageCount])
    @@map("club_models")
}

model Product {
    id          String           @id @default(cuid())
    title       String
    description String
    price       Float
    condition   ProductCondition
    // Brand relationship (controlled)
    brandId     String?
    brand       Brand?           @relation(fields: [brandId], references: [id], onDelete: SetNull)
    // Model field (hybrid - free text for flexibility)
    model       String?
    // Golf club specific fields
    flex        String? // Shaft flex: "L", "A", "R", "S", "X"
    loft        String? // Club loft in degrees: "9°", "56°", etc.
    userId      String
    user        User             @relation(fields: [userId], references: [id], onDelete: Cascade)
    categoryId  String
    category    Category         @relation(fields: [categoryId], references: [id])
    images      ProductImage[]
    isSold      Boolean          @default(false)
    views       Int              @default(0)
    // Shipping dimensions for EasyPost (in cm and grams)
    length      Float? // Length in cm
    width       Float? // Width in cm
    height      Float? // Height in cm
    weight      Float? // Weight in grams
    createdAt   DateTime         @default(now())
    updatedAt   DateTime         @updatedAt
    orders      Order[]
    offers      Offer[]
    favourites  Favourite[]

    @@index([categoryId])
    @@index([userId])
    @@index([brandId])
    @@index([isSold])
    @@index([views])
    @@map("products")
}

model ProductImage {
    id        String   @id @default(cuid())
    url       String
    productId String
    product   Product  @relation(fields: [productId], references: [id], onDelete: Cascade)
    sortOrder Int      @default(0)
    createdAt DateTime @default(now())

    @@index([productId])
    @@map("product_images")
}

model Favourite {
    id        String   @id @default(cuid())
    userId    String
    user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
    productId String
    product   Product  @relation(fields: [productId], references: [id], onDelete: Cascade)
    createdAt DateTime @default(now())

    @@unique([userId, productId])
    @@index([userId])
    @@index([productId])
    @@map("favourites")
}

enum ProductCondition {
    NEW
    LIKE_NEW
    EXCELLENT
    GOOD
    FAIR
    POOR
}

model Address {
    id         String   @id @default(cuid())
    userId     String
    user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
    name       String // Full name for shipping
    street1    String
    street2    String?
    city       String
    state      String
    zip        String
    country    String   @default("US")
    phone      String?
    isDefault  Boolean  @default(false)
    createdAt  DateTime @default(now())
    updatedAt  DateTime @updatedAt
    ordersFrom Order[]  @relation("FromAddress")
    ordersTo   Order[]  @relation("ToAddress")

    @@index([userId])
    @@map("addresses")
}

model Order {
    id                 String         @id @default(cuid())
    // Stripe payment information
    stripePaymentId    String?        @unique // Nullable in case of payment processing delays
    stripeCheckoutId   String?
    amountTotal        Float // Total amount paid (including shipping)
    shippingCost       Float // Shipping cost charged
    // Stripe Connect payout tracking
    stripePlatformFee  Float? // Platform fee amount (10%)
    stripeSellerPayout Float? // Amount paid out to seller
    stripeTransferId   String? // Stripe Transfer ID for seller payout
    stripePayoutStatus String? // Payout status (pending, paid, failed)
    stripePayoutDate   DateTime? // Date payout was sent to seller
    // Order participants
    sellerId           String
    seller             User           @relation("SellerOrders", fields: [sellerId], references: [id])
    buyerId            String
    buyer              User           @relation("BuyerOrders", fields: [buyerId], references: [id])
    productId          String
    product            Product        @relation(fields: [productId], references: [id])
    // Shipping addresses
    fromAddressId      String
    fromAddress        Address        @relation("FromAddress", fields: [fromAddressId], references: [id])
    toAddressId        String
    toAddress          Address        @relation("ToAddress", fields: [toAddressId], references: [id])
    // EasyPost shipping information
    easypostShipmentId String? // EasyPost shipment ID
    labelUrl           String? // URL to download shipping label
    labelFormat        String? // Label format (PDF, PNG, etc.)
    trackingCode       String? // Carrier tracking number
    trackingUrl        String? // URL to track shipment
    carrier            String? // Shipping carrier (USPS, UPS, FedEx, etc.)
    service            String? // Service level (First, Priority, Ground, etc.)
    shipmentStatus     ShipmentStatus @default(PENDING)
    estimatedDelivery  DateTime? // Estimated delivery date
    actualDelivery     DateTime? // Actual delivery date
    // Order lifecycle
    status             OrderStatus    @default(PAYMENT_CONFIRMED)
    labelGeneratedAt   DateTime?
    shippedAt          DateTime?
    deliveredAt        DateTime?
    createdAt          DateTime       @default(now())
    updatedAt          DateTime       @updatedAt
    // Seller rating
    sellerRating       SellerRating?

    @@index([sellerId])
    @@index([buyerId])
    @@index([productId])
    @@index([shipmentStatus])
    @@index([status])
    @@map("orders")
}

enum ShipmentStatus {
    PENDING // Awaiting label generation
    PRE_TRANSIT // Label created, not yet in transit
    IN_TRANSIT // Package is on its way
    OUT_FOR_DELIVERY // Out for delivery
    DELIVERED // Successfully delivered
    RETURNED // Package returned to sender
    FAILED // Delivery failed
    CANCELLED // Shipment cancelled
}

enum OrderStatus {
    PAYMENT_CONFIRMED // Payment successful, awaiting label
    LABEL_GENERATED // Shipping label created
    SHIPPED // Package shipped by seller
    DELIVERED // Package delivered to buyer
    CANCELLED // Order cancelled
    REFUNDED // Order refunded
}

model SellerRating {
    id        String   @id @default(cuid())
    // Who is being rated
    sellerId  String
    seller    User     @relation("SellerRatings", fields: [sellerId], references: [id], onDelete: Cascade)
    // Who is leaving the rating
    buyerId   String
    buyer     User     @relation("RatingsGiven", fields: [buyerId], references: [id], onDelete: Cascade)
    // Associated order (one rating per order)
    orderId   String   @unique
    order     Order    @relation(fields: [orderId], references: [id], onDelete: Cascade)
    // Rating (1-5 stars)
    rating    Int // 1-5 stars overall
    // Optional review text
    comment   String?  @db.Text
    // Timestamps
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@index([sellerId])
    @@index([buyerId])
    @@index([orderId])
    @@map("seller_ratings")
}

model Offer {
    id            String         @id @default(cuid())
    amount        Float
    status        OfferStatus    @default(PENDING)
    message       String?        @db.Text
    expiresAt     DateTime? // Offers expire after 7 days if not accepted/rejected
    productId     String
    product       Product        @relation(fields: [productId], references: [id], onDelete: Cascade)
    buyerId       String
    buyer         User           @relation("BuyerOffers", fields: [buyerId], references: [id], onDelete: Cascade)
    sellerId      String
    seller        User           @relation("SellerOffers", fields: [sellerId], references: [id], onDelete: Cascade)
    createdAt     DateTime       @default(now())
    updatedAt     DateTime       @updatedAt
    counterOffers CounterOffer[]

    @@index([productId])
    @@index([buyerId])
    @@index([sellerId])
    @@index([status])
    @@index([expiresAt])
    @@map("offers")
}

model CounterOffer {
    id         String   @id @default(cuid())
    amount     Float
    message    String?  @db.Text
    fromSeller Boolean
    offerId    String
    offer      Offer    @relation(fields: [offerId], references: [id], onDelete: Cascade)
    createdAt  DateTime @default(now())

    @@index([offerId])
    @@map("counter_offers")
}

enum OfferStatus {
    PENDING
    ACCEPTED
    REJECTED
    COUNTERED
    EXPIRED
}

// Pre-launch waitlist signups
model Waitlist {
    id        String   @id @default(cuid())
    email     String   @unique
    source    String   @default("coming-soon") // Where the signup came from
    createdAt DateTime @default(now())

    @@map("waitlist")
}
